===============================
Events, Metrics, and Statistics
===============================


Why Customise Statistics?
=========================

`Customising statistics is like adjusting the lighting in a theatrical production: it highlights key moments and reveals`
`details that might otherwise go unnoticed, ensuring that each scene contributes to the overall narrative in a meaningful`
`and impactful way.`

In a simulated environment, customising statistics is not just about data collection but about optimising our understanding
of the system.


What Do We Want to Discover?
----------------------------

It is essential to define what we want to uncover. Continuing with our main idea of smart mobility—focused on the interaction
between taxis, customers, and energy systems—we can set the objective of unveiling patterns and relationships that guide
decision-making. For example:

#. **Understanding Behaviours:** Analyse how agents, such as customers and taxis, interact within the system. This includes identifying trends in their decisions and actions, as well as the conditions that motivate them.
#. **Measuring Efficiency:** Evaluate how resources are utilised within the system, from agents' time to energy consumption, ensuring optimal performance.
#. **Predicting Future Demands:** Use historical data and emerging patterns to anticipate how the system's needs will evolve, such as changes in transport demand or stress on energy infrastructure.
#. **Assessing Environmental Impact:** Examine how the decisions and actions of agents influence external factors, such as customer wait times, traffic, or the load on charging stations.

These areas of discovery allow us not only to analyse the current state of the system but also to explore opportunities
for its improvement and long-term optimisation.


Event Management
================

Class Event and Its Role in the System
--------------------------------------

The Event class is fundamental for managing events within the system. Its primary purpose is to represent a specific occurrence
or action related to key performance indicators (KPIs) and the agents involved. Each instance of this class captures critical
details, such as:

* **Event Name:** Identifies the associated agent or entity.

* **Event Type:** Classifies the occurrence (e.g., request received, trip started).

* **Class of Involved Agent:** Provides context about the type of entity related to the event.

* **Timestamp:** Records when the event occurred, enabling chronological analysis.

* **Details:** A dictionary to store additional relevant information about the event.

The class's flexibility in converting events to dictionaries makes it highly effective for generating logs, storing data,
and performing subsequent analysis.


Class StatisticsStore
---------------------

The `StatisticsStore` class acts as a central repository for storing, querying, and analysing events related to the performance
of a specific agent. This class not only organises events but also enables filtering, transformation, and exportation of the
data for more detailed analysis.

**Main Methods**

.. code-block:: python


    def get_agent_name(self)
    def emit(self, event_type: str, details: Optional[Dict] = None, timestamp: Optional[str] = None)
    def all(self, limit: Optional[int] = None)
    def all_events(self)
    def generate_partial_log(self)

* ``get_agent_name()``
Returns the name of the agent associated with this instance.

* ``emit()``
Records a new event in the store by creating an instance of the `Event` class and adding it to the list of events.

* ``all()``
Returns all stored events, with the option to limit the number of events returned.

* ``all_events()``
Returns all events in dictionary format, making them easier to view or export.

* ``generate_partial_log()``
Creates a Log object containing the registered events, enabling further filtering and manipulation.

These functions make `StatisticsStore` a crucial checkpoint for monitoring and analysing an agent's activity in real-time or during post-analysis.


Event Logging (Log)
===================

The Log class centralises and organises events generated by each agent during a simulation. While each agent records its
own events, the Log class allows them to be grouped together, making data querying, analysis, and manipulation more straightforward.
This is particularly useful for creating consolidated reports, generating specific statistics, or exporting records in JSON format
for further analysis.

This centralisation simplifies access to events generated by multiple agents and ensures a standardised format for post-simulation analysis.

.. note::
    The simulator automatically centralises events from all agents into a Log object using the ``generate_partial_log()``
method of the `StatisticsStore` class.


Log Filtering
-------------

The primary goal of filtering is to extract subsets of events based on specific criteria, such as agent name, class type,
event type, or a time range. This is essential for focusing on relevant information and minimising noise when analysing
large volumes of data.


**Main Methods**

.. code-block:: python


    def filter(self, criterion: Callable[[Event], bool])
    def filter_by_name(self, name: str)
    def filter_by_class_type(self, class_type: str)
    def filter_by_event_type(self, event_type: str)
    def filter_by_time_window(self, start_time: datetime, end_time: datetime)


* ``filter()``
Applies a criterion function to each event and returns a new Log object containing the events that meet the criterion.
This serves as the foundation for other filtering methods.

* ``filter_by_name()``
Filters events by the agent's name.

* ``filter_by_class_type()``
Filters events based on the associated class type.

* ``filter_by_event_type()``
Extracts events of a specific type, such as `customer_request` or `trip_completion`.

* ``filter_by_time_window()``
Selects events that occurred within a defined time range.


Manipulation and Export of Logs
-------------------------------

The primary goal of log manipulation and export is to transform data into useful and accessible structures for analysis
and export the results in formats like JSON or pandas DataFrames.

**Main Methods**

.. code-block:: python


    def drop(self, fields: List[str])
    def all_events(self)
    def add_events(self, other_log: 'Log')
    def adjust_timestamps(self, simulator_timestamp: str)
    def sort_by_timestamp(self, reverse: bool = False)
    def to_dataframe(self, event_fields: List[str], details_fields: List[str])

* ``drop()``
Removes specific fields from the details of each event, simplifying the information for focused analyses.

* ``all_events()``
Returns all events as a list of dictionaries.

* ``add_events()``
Merges events from another Log, useful for consolidating records from different agents.

* ``adjust_timestamps()``
Adjusts the timestamps of events to align them with the simulator's time, ensuring temporal consistency.

* ``sort_by_timestamp()``
Sorts events by their timestamp, enabling the analysis of the chronological flow of activities.

* ``to_dataframe()``
Converts events into a DataFrame, facilitating calculations and visualisations using tools like pandas.


Generating Statistics
=====================

How Do I Generate Statistics?
-----------------------------

To generate statistics in the simulator, it is essential to include event emissions (emit) in the agent's behavioural
strategy. This enables the logging of key events that occur during the simulation, which will be processed later.
For example, in the taxi customer strategies module (``taxicustomer.py``), key events related to customer behaviour
are emitted, such as:

#. **Customer Request** (``customer_request``): Emitted when the customer makes a transport request.

#. **Transport Offer Acceptance** (``transport_offer_acceptance``): Logged when the customer accepts a transport offer.

#. **Customer Pickup** (``customer_pickup``): Emitted when the customer is picked up by the transport.

#. **Trip Completion** (``trip_completion``): Logged when the customer arrives at their destination.

The following code snippet from the ``taxicustomer.py`` module demonstrates how these events are emitted to log them:


.. code-block:: python


    class AcceptFirstRequestBehaviour(TaxiCustomerStrategyBehaviour):

        async def run(self):

            if self.agent.status is None:
                self.agent.status = CUSTOMER_WAITING
                return

            if self.agent.get_fleetmanagers() is None:

                fleetmanager_list = await self.agent.get_list_agent_position(self.agent.fleet_type, self.agent.get_fleetmanagers())
                self.agent.set_fleetmanagers(fleetmanager_list)
                return

            if self.agent.status == CUSTOMER_WAITING:

                # New statistics
                # Event 1: Customer Request
                self.agent.events_store.emit(
                    event_type="customer_request",
                    details={}
                )

                await self.send_request(content={})

            try:
                msg = await self.receive(timeout=5)

                if msg:
                    performative = msg.get_metadata("performative")
                    transport_id = msg.sender
                    content = json.loads(msg.body)
                    logger.debug("Agent[{}]: The agent informed of: {}".format(self.agent.name, content))

                    # Handle transport proposals.
                    if performative == PROPOSE_PERFORMATIVE:
                        if self.agent.status == CUSTOMER_WAITING:
                            logger.debug(
                                "Agent[{}]: The agent received proposal from transport [{}]".format(
                                    self.agent.name, transport_id
                                )
                            )

                            # New statistics
                            # Event 3: Transport Offer Acceptance
                            self.agent.events_store.emit(
                                event_type="transport_offer_acceptance",
                                details={}
                            )

                            await self.accept_transport(transport_id)
                            self.agent.status = CUSTOMER_ASSIGNED
                        else:
                            await self.refuse_transport(transport_id)

                    elif performative == CANCEL_PERFORMATIVE:
                        if self.agent.transport_assigned == str(transport_id):
                            logger.warning(
                                "Agent[{}]: The agent received a CANCEL from Transport [{}].".format(
                                    self.agent.name, transport_id
                                )
                            )
                            self.agent.status = CUSTOMER_WAITING

                    elif performative == INFORM_PERFORMATIVE:
                        if "status" in content:
                            status = content["status"]

                            if status == TRANSPORT_MOVING_TO_CUSTOMER:
                                logger.info(
                                    "Agent[{}]: The agent waiting for transport.".format(self.agent.name)
                                )

                                # New statistics
                                # Event 4: Travel for Pickup
                                self.agent.events_store.emit(
                                    event_type="wait_for_pickup",
                                    details={}
                                )

                            elif status == TRANSPORT_IN_CUSTOMER_PLACE:
                                self.agent.status = CUSTOMER_IN_TRANSPORT
                                logger.info("Agent[{}]: The agent in transport.".format(self.agent.name))

                                # New statistics
                                # Event 5: Customer Pickup
                                self.agent.events_store.emit(
                                    event_type="customer_pickup",
                                    details={}
                                )

                                # New statistics
                                # Event 6: Travel to destination
                                self.agent.events_store.emit(
                                    event_type="travel_to_destination",
                                    details={}
                                )

                                await self.inform_transport(transport_id, CUSTOMER_IN_TRANSPORT)
                            elif status == CUSTOMER_IN_DEST:
                                self.agent.status = CUSTOMER_IN_DEST

                                # New statistics
                                # Event 7: Travel to destination
                                self.agent.events_store.emit(
                                    event_type="trip_completion",
                                    details={}
                                )

                                await self.inform_transport(transport_id, CUSTOMER_IN_DEST)
                                logger.info(
                                    "Agent[{}]: The agent arrived to destination.".format(
                                        self.agent.name
                                    )
                                )

            except CancelledError:
                logger.debug("Cancelling async tasks...")

            except Exception as e:
                logger.error(
                    "EXCEPTION in AcceptFirstRequestBehaviour of agent [{}]: {}".format(
                        self.agent.name, e
                    )
                )


Each of these events is stored in an events log (events_log) that the simulator uses at the end of the simulation to
compute metrics and generate specific statistics.


.. note::
    Adding emit statements at critical points in the agent's strategy ensures that all important events are logged
    and can be processed during the statistical analysis phase.


Guide: Taxi Customer Metrics
----------------------------

Once events are properly configured in the agent's strategy, as described in the previous step, the simulator uses these
events to generate statistics at the end of the simulation. This process is carried out through a customised statistics
class that the user must create, based on the ``basestatistics.py`` module.


Creating the Statistics Class
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. note::
    The ``basestatistics.py`` module defines an abstract base class (BaseStatisticsClass) that serves as a template for any
    customised statistics class. This class requires implementing the abstract method run(events_log: Log), which processes
    the metrics you define.

.. code-block:: python


    class BaseStatisticsClass(ABC):
        @abstractmethod
        def run(self, events_log: Log) -> None:
            raise NotImplementedError("Subclasses must implement the run method.")

        def print_stats(self) -> None:
            raise NotImplementedError("No statistics are printed because it has not been implemented.")


The user must create a specific class inheriting from `BaseStatisticsClass`, as demonstrated in the ``mobilitystatistics.py`` module.
For example, the `MobilityStatisticsClass` implements the run method and defines submethods to calculate specific metrics
related to taxi customers:

.. code-block:: python
    class MobilityStatisticsClass(BaseStatisticsClass):

    def run(self, events_log: Log) -> None:

        self.customer_taxi_metrics(events_log, "simfleet_metrics_taxicustomer.json")

        self.print_stats()


Generating Customer Metrics
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Within this class, the ``customer_taxi_metrics()`` method processes events related to customers to calculate key metrics such as
wait times, trip durations, and more. This method transforms events into a structured format and then exports the results
as a JSON file.


.. code-block:: python

    def customer_taxi_metrics(self, events_log: Log, file_path: str) -> None:

        # Filtering relevant events for TaxiCustomerAgent
        filtered_events = events_log.filter(lambda event: event.class_type == "TaxiCustomerAgent" and
                                                          event.event_type in {'customer_request', 'customer_pickup',
                                                                               'trip_completion'})

        # Transform events into a DataFrame
        event_fields = ["name", "timestamp", "event_type", "class_type"]
        details_fields = []
        dataframe = filtered_events.to_dataframe(event_fields=event_fields, details_fields=details_fields)

        # Using pivot table to calculate waiting time and total trip time
        pivot_df = dataframe.pivot_table(index="name", columns="event_type", values="timestamp", aggfunc="first")
        waiting_time = (pivot_df["customer_pickup"] - pivot_df["customer_request"])
        total_time = (pivot_df["trip_completion"] - pivot_df["customer_request"])

        # Combining all metrics into a final DataFrame
        result_df = pd.DataFrame({
            "name": dataframe.groupby("name")["name"].first(),
            "class_type": dataframe.groupby("name")["class_type"].first(),
            "waiting_time": waiting_time,
            "total_time": total_time
        }).fillna(0)

        # Clear duplicate column names
        self.taxicustomer_df = result_df.reset_index(drop=True)

        # Calculating general averages for the "GeneralMetrics" section
        avg_waiting_time = self.taxicustomer_df["waiting_time"].mean()
        avg_total_time = self.taxicustomer_df["total_time"].mean()

        # Convert the DataFrame into a dictionary structure indexed by an agent number
        agent_metrics = self.taxicustomer_df.to_dict(orient="records")

        # Convert the agent metrics into a dictionary with numeric keys (0, 1, 2, ...)
        numbered_agents = {str(i): agent_metrics[i] for i in range(len(agent_metrics))}

        # Converting the result DataFrame into a JSON-like structure
        json_structure = {
            "GeneralMetrics": {
                "Class type": "TaxiCustomerAgent",
                "Avg Waiting Time": f"{avg_waiting_time:.2f}",
                "Avg Total Time": f"{avg_total_time:.2f}"
            },
            "TaxiCustomerAgent": numbered_agents
        }

        # Exporting the result to a JSON file
        self.export_to_json(json_structure, file_path)

Automatic Execution
~~~~~~~~~~~~~~~~~~~

When the simulation ends, the simulator automatically executes the configured statistics class, generating the results
in a specified file (e.g., ``simfleet_metrics_taxicustomer.json``). This provides a detailed analysis of agent performance.
